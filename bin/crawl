#!/usr/bin/env ruby
#
# Script to grab random documents of different filetypes from google
#
#http://www.google.com/#q=filetype:pdf&start=40&num=100
require 'cgi'
require 'open-uri'
require 'hpricot'
require 'getoptlong'
require 'mkmf'
require 'digest/sha2'

#
# Function to tell user the usage
#
def usage()
    usageStr = <<-USAGEND
Usage: crawl [options] 
    --filetype  (-f)    Filetype to download examples (ex. pdf, doc, ppt) 
    --help      (-h)    Display the usage information 
    --num       (-n)    Number of files to download 

    USAGEND
    puts usageStr
    exit(1)
end

# Function to parse program options
# @param [GetoptLong] Configuration for GetoptLong library
def parse_options(opts)
    config = Hash.new()

    opts.each do |opt, arg|
        case opt
        when '--filetype'
            config['filetype'] = arg
        when '--help'
            usage()
        when '--num'
            config['num'] = arg.to_i
        else
            usage()
        end
    end

    return(config)
end

# Function to create lambdas for downloading a file
#
def create_downloader()
	#
	# Try to find wget for faster download
	#
	wget = find_executable("wget")

	# Write the corresponding lambda based on capabilities
	if(wget == nil) then
		downloader =  lambda do |filename, href|
			fh = File.open(filename, "w+") do
				open(href) do |fileUrl|
					fh.write(fileUrl.read())
				end
			end
		end
	else
		downloader = lambda do |filename, href|
			system("wget -O #{filename} \"#{href}\"")
		end	
	end

	return(downloader)
end

opts = GetoptLong.new(
                ['--filetype',      '-f', GetoptLong::REQUIRED_ARGUMENT],
                ['--num',           '-n', GetoptLong::REQUIRED_ARGUMENT],
                ['--help',          '-h', GetoptLong::NO_ARGUMENT])


#
# Parse the command line options 
#
config = parse_options(opts)

#
# Error Check
#
if(config['filetype'] == nil || config['num'] == nil) then
    usage()
end

#
# Create the base url
#
url = "http://www.google.com/search?q=filetype:#{config['filetype']}&filter=0"

downloader = create_downloader()			

#
# Seed the pseudo-random number generator
# 
srand(Time.now().to_i)

#
# File Hashes
#
fileSignatures = Hash.new()

docsCollected = 0
while docsCollected < config['num'] do
	# 1000 is the maximum returned by a google search
    doc = Hpricot(open(url + "&start=" + rand(1000).to_s()).read)

    (doc/"li[@class='g']").each do |li|

        #
        # Check for reaching threshold
        #
        if(docsCollected >= config['num']) then
            break
        end

		#
		# Check th filetype
		#
		filetype = li.search("span[@class='f']") 
		if(filetype.nil?) then
			next	
		end

        link = li.search("a[@class='l']")
        
        puts "-----------------------------"
        puts link.first.attributes['href']
        puts "-----------------------------"

		# Download the file
		filename = "#{docsCollected}.#{config['filetype']}"
		downloader.call(filename, link.first.attributes['href'])	
        

		#
		# Hash the file
		#
		fileSHA2sig = Digest::SHA2.new() 
		File.open(filename, 'r') do |fh|
			while buffer = fh.read(1024)
				fileSHA2sig << buffer
			end
		end

		if(fileSignatures.has_key?(fileSHA2sig)) then
				FileUtils.rm("#{docsCollected}.#{config['filetype']}")
		else
			fileSignatures[fileSHA2sig] = true
			docsCollected = docsCollected + 1
		end
    end
end
