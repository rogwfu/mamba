#!/usr/bin/env ruby
# Script to grab random documents of different filetypes from google
#http://www.google.com/#q=filetype:pdf&start=40&num=100
require 'cgi'
require 'open-uri'
require 'hpricot'
require 'getoptlong'
require 'mkmf'
require 'digest/sha2'

# Function to tell user the usage
def usage()
	usageStr = <<-USAGEND
Usage: crawl [options] 
	--filetype  (-f)    Filetype to download examples (ex. pdf, doc, ppt) 
	--help      (-h)    Display the usage information 
	--num       (-n)    Number of files to download 

	USAGEND
	puts usageStr
	exit(1)
end

# Function to parse program options
# @param [GetoptLong] Configuration for GetoptLong library
def parse_options(opts)
	config = Hash.new()

	opts.each do |opt, arg|
		case opt
		when '--filetype'
			config['filetype'] = arg
		when '--help'
			usage()
		when '--num'
			config['num'] = arg.to_i
		else
			usage()
		end
	end

	return(config)
end

# Class To download files from google
class Downloader
	# Create an instance of the Downloader class
	# @param [String] The filetype to filter google searches
	def initialize(filetype)
		# Create a hash to hold all signatures
		@fileSignatures = Hash.new()

		# Create the base url
		@url = "http://www.google.com/search?q=filetype:#{filetype}&filter=0"
		srand(Time.now().to_i)

		# Try to find wget for faster download
		wget = find_executable("wget")

		# Write the corresponding lambda based on capabilities
		if(wget == nil) then
			@downloader =  lambda do |filename, href|
				fh = File.open(filename, "w+") do
					open(href) do |fileUrl|
						fh.write(fileUrl.read())
					end
				end
			end
		else
			@downloader = lambda do |filename, href|
				system("wget -O #{filename} --timeout=120 \"#{href}\"")
			end	
		end

		return(self)
	end

	# Download a file
	# @param [Fixnum] The number of files requested to download 
	# @param [String] File suffix to append to filenames during normalization
	def download(numRequestedFiles, fileSuffix)
		docsCollected = 0
		while docsCollected < numRequestedFiles do
			# 1000 is the maximum returned by a google search
			doc = Hpricot(open(@url + "&start=" + rand(1000).to_s()).read)

			# Download all the files on the page
			(doc/"li[@class='g']").each do |li|

				# Check for reaching threshold
				if(docsCollected >= numRequestedFiles) then
					break
				end

				# Check th filetype
				filetype = li.search("span[@class='f']") 
				if(filetype.nil?) then
					next	
				end

				# Pull out the download link
				link = li.search("a[@class='l']")

				# Debugging
				exemplarName = "#{docsCollected}.#{fileSuffix}"
				puts "-----------------------------"
				puts "#{exemplarName}:#{link.first.attributes['href']}"
				puts "-----------------------------"

				# Download the file
				@downloader.call(exemplarName, link.first.attributes['href'])	

				# Check for uniqueness
				exemplarHash = hash(exemplarName)
				if(downloaded?(exemplarHash) or File.stat(exemplarName).size == 0) then
					FileUtils.rm(exmplarName)
				else
					@fileSignatures[exemplarHash] = true
					docsCollected +=  1
				end
			end
		end
	end

	private

	# Hash the file just downloaded
	# @param [String] Downloaded file's name
	# @return [String] SHA256 hex digest of the file
	def hash(filename)
		# Hash the file
		return(Digest::SHA256.file(filename).hexdigest())
	end

	# Hash lookup to determine if the file already exists
	# @param [String] Hex digest of a file
	# @returns [Boolean] Whether the file exists or not
	def downloaded?(hexDigest)
		# Check to see if file already downloaded
		if(@fileSignatures.has_key?(hexDigest)) then
			return(true)
		else
			return(false)
		end
	end
end


# Create the available options
opts = GetoptLong.new(
	['--filetype',      '-f', GetoptLong::REQUIRED_ARGUMENT],
	['--num',           '-n', GetoptLong::REQUIRED_ARGUMENT],
	['--help',          '-h', GetoptLong::NO_ARGUMENT])

# Parse the command line options 
config = parse_options(opts)

# Error Check
if(config['filetype'] == nil || config['num'] == nil) then
	usage()
end

# Create a downloader and download files
Downloader.new(config['filetype']).download(config['num'], config['filetype'])
